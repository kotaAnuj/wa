<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Object Tracking & Detection</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: Arial, sans-serif; 
            background: #1a1a2e; 
            color: #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        h1 { margin-bottom: 20px; color: #00d9ff; }
        .container { 
            position: relative; 
            max-width: 640px; 
            width: 100%;
        }
        video, canvas { 
            width: 100%; 
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,217,255,0.3);
        }
        canvas { 
            position: absolute; 
            top: 0; 
            left: 0; 
        }
        .controls { 
            margin-top: 20px; 
            display: flex; 
            gap: 10px;
            flex-wrap: wrap;
        }
        button { 
            padding: 10px 20px; 
            border: none; 
            border-radius: 5px; 
            background: #00d9ff; 
            color: #1a1a2e; 
            font-weight: bold;
            cursor: pointer;
            transition: 0.3s;
        }
        button:hover { background: #00b8d4; transform: translateY(-2px); }
        button:disabled { background: #555; cursor: not-allowed; }
        .info { 
            margin-top: 20px; 
            padding: 15px; 
            background: #16213e; 
            border-radius: 8px;
            width: 100%;
            max-width: 640px;
        }
        .status { 
            display: flex; 
            gap: 20px; 
            flex-wrap: wrap;
            margin-bottom: 10px;
        }
        .status div { 
            padding: 8px 15px; 
            background: #0f3460; 
            border-radius: 5px;
        }
        .alert { 
            padding: 10px; 
            background: #d32f2f; 
            border-radius: 5px; 
            margin-top: 10px;
            display: none;
        }
        .alert.show { display: block; }
    </style>
</head>
<body>
    <h1>üéØ Object Tracking & Person Detection</h1>
    
    <div class="container">
        <video id="video" autoplay playsinline></video>
        <canvas id="canvas"></canvas>
    </div>
    
    <div class="controls">
        <button id="startBtn">Start Camera</button>
        <button id="trackBtn" disabled>Enable Tracking</button>
        <button id="detectBtn" disabled>Detect Motion</button>
    </div>
    
    <div class="info">
        <div class="status">
            <div>Objects: <span id="objCount">0</span></div>
            <div>Motion: <span id="motion">None</span></div>
            <div>FPS: <span id="fps">0</span></div>
        </div>
        <div class="alert" id="alert">‚ö†Ô∏è Object detected in path!</div>
    </div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const trackBtn = document.getElementById('trackBtn');
        const detectBtn = document.getElementById('detectBtn');
        const objCount = document.getElementById('objCount');
        const motion = document.getElementById('motion');
        const fpsDisplay = document.getElementById('fps');
        const alert = document.getElementById('alert');

        let tracking = false;
        let detecting = false;
        let prevFrame = null;
        let objects = [];
        let frameCount = 0;
        let lastTime = Date.now();

        // Start camera
        startBtn.addEventListener('click', async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 640, height: 480 } 
                });
                video.srcObject = stream;
                video.addEventListener('loadedmetadata', () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    trackBtn.disabled = false;
                    detectBtn.disabled = false;
                    startBtn.disabled = true;
                });
            } catch (err) {
                alert('Camera access denied: ' + err.message);
            }
        });

        // Toggle tracking
        trackBtn.addEventListener('click', () => {
            tracking = !tracking;
            trackBtn.textContent = tracking ? 'Stop Tracking' : 'Enable Tracking';
            if (tracking) processFrame();
        });

        // Toggle detection
        detectBtn.addEventListener('click', () => {
            detecting = !detecting;
            detectBtn.textContent = detecting ? 'Stop Detection' : 'Detect Motion';
        });

        // Simple object detection using color-based tracking
        function detectObjects(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const detected = [];
            const gridSize = 40;
            
            // Divide frame into grid and detect motion/objects
            for (let y = 0; y < height; y += gridSize) {
                for (let x = 0; x < width; x += gridSize) {
                    let brightness = 0;
                    let count = 0;
                    
                    for (let dy = 0; dy < gridSize && y + dy < height; dy++) {
                        for (let dx = 0; dx < gridSize && x + dx < width; dx++) {
                            const i = ((y + dy) * width + (x + dx)) * 4;
                            brightness += (data[i] + data[i + 1] + data[i + 2]) / 3;
                            count++;
                        }
                    }
                    
                    const avgBrightness = brightness / count;
                    
                    // Detect significant bright areas (simple person/object detection)
                    if (avgBrightness > 100) {
                        detected.push({ x, y, size: gridSize, brightness: avgBrightness });
                    }
                }
            }
            
            return detected;
        }

        // Motion detection
        function detectMotion(currentData, previousData) {
            if (!previousData) return 0;
            
            let diff = 0;
            for (let i = 0; i < currentData.length; i += 4) {
                const d = Math.abs(currentData[i] - previousData[i]) +
                         Math.abs(currentData[i + 1] - previousData[i + 1]) +
                         Math.abs(currentData[i + 2] - previousData[i + 2]);
                diff += d;
            }
            
            return diff / (currentData.length / 4);
        }

        // Check for obstacles in path (center area)
        function checkObstacles(detectedObjects) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const threshold = 150;
            
            for (let obj of detectedObjects) {
                const distX = Math.abs(obj.x - centerX);
                const distY = Math.abs(obj.y - centerY);
                
                if (distX < threshold && distY < threshold) {
                    return true;
                }
            }
            return false;
        }

        // Process each frame
        function processFrame() {
            if (!tracking) return;
            
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // Detect objects
            objects = detectObjects(imageData);
            objCount.textContent = objects.length;
            
            // Draw detected objects
            objects.forEach(obj => {
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.strokeRect(obj.x, obj.y, obj.size, obj.size);
                
                // Label objects
                ctx.fillStyle = '#00ff00';
                ctx.font = '12px Arial';
                ctx.fillText('Object', obj.x, obj.y - 5);
            });
            
            // Motion detection
            if (detecting && prevFrame) {
                const motionLevel = detectMotion(imageData.data, prevFrame);
                motion.textContent = motionLevel > 10 ? 'Detected' : 'None';
                
                if (motionLevel > 10) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }
            
            // Obstacle avoidance
            const hasObstacle = checkObstacles(objects);
            if (hasObstacle) {
                alert.classList.add('show');
                // Draw warning box in center
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 3;
                ctx.strokeRect(canvas.width/2 - 75, canvas.height/2 - 75, 150, 150);
                ctx.fillStyle = '#ff0000';
                ctx.font = '16px Arial';
                ctx.fillText('‚ö†Ô∏è OBSTACLE', canvas.width/2 - 50, canvas.height/2);
            } else {
                alert.classList.remove('show');
            }
            
            // Draw center reference point
            ctx.fillStyle = '#00d9ff';
            ctx.beginPath();
            ctx.arc(canvas.width/2, canvas.height/2, 5, 0, Math.PI * 2);
            ctx.fill();
            
            prevFrame = new Uint8ClampedArray(imageData.data);
            
            // Calculate FPS
            frameCount++;
            const now = Date.now();
            if (now - lastTime >= 1000) {
                fpsDisplay.textContent = frameCount;
                frameCount = 0;
                lastTime = now;
            }
            
            requestAnimationFrame(processFrame);
        }
    </script>
</body>
</html>
