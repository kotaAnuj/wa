<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Fast & Reliable Person Tracker — EMA + Kalman + PID</title>

<!-- TF and MoveNet -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>

<style>
  :root{--bg:#000;--accent:#1eff7a}
  html,body{height:100%; margin:0; background:var(--bg); color:var(--accent); font-family:system-ui,monospace}
  video{display:none} /* hide the raw video element to reduce repaints */
  canvas{position:absolute; inset:0; width:100vw; height:100vh; object-fit:cover}
  #ui {position:absolute; left:8px; top:8px; background:rgba(0,0,0,0.45); padding:8px 10px; border-radius:8px}
  #cmd {position:absolute; left:50%; transform:translateX(-50%); bottom:18px; background:rgba(0,0,0,0.6); padding:10px 14px; border-radius:10px; font-size:18px}
  small{color:#9f9}
</style>
</head>
<body>
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>
  <div id="ui">
    <div id="status">Status: init</div>
    <div id="stats"><small>fps: -- | latency: -- ms</small></div>
  </div>
  <div id="cmd">Command: --</div>

<script>
/* =========================
   CONFIG — tune for speed
   ========================= */
const CONFIG = {
  // Performance
  REQUESTED_WIDTH: 640,       // lower => faster inference, try 480 or 640
  REQUESTED_HEIGHT: 480,
  TARGET_FPS: 15,             // target detection fps
  MOVE_NET_MODEL: "Lightning",// Lightning = fastest, Thunder = more accurate slower
  MIN_KEYPOINT_SCORE: 0.45,

  // Control & smoothing
  EMA_ALPHA_X: 0.16,
  EMA_ALPHA_SHOULDER: 0.12,
  KALMAN_Q: 0.01,
  KALMAN_R: 0.08,
  PID: { kP: 0.007, kI: 0.0006, kD: 0.002 },
  HORIZ_BASE_DEADZONE: 56,    // px

  // Command sending
  sendMode: "none", // "none" | "websocket" | "http"
  websocketUrl: "ws://192.168.4.1:81",
  httpUrl: "http://192.168.4.1/control",

  // Other
  debugDraw: true
};

/* =========================
   Lightweight helpers
   ========================= */
class EMA {
  constructor(alpha){ this.a = alpha; this.v = null; }
  update(x){ if (this.v === null) this.v = x; else this.v = this.a * x + (1 - this.a) * this.v; return this.v; }
}
class Kalman {
  constructor(Q,R){ this.Q=Q; this.R=R; this.P=1; this.X=0; }
  update(z){ this.P += this.Q; const K = this.P / (this.P + this.R); this.X += K * (z - this.X); this.P *= (1 - K); return this.X; }
}
class PID {
  constructor(kP,kI,kD){ this.kP=kP; this.kI=kI; this.kD=kD; this.int=0; this.prev=0; }
  update(err, dt){ this.int += err * dt; const deriv = dt>0 ? (err - this.prev)/dt : 0; this.prev = err; return this.kP*err + this.kI*this.int + this.kD*deriv; }
}
class MovingAvg {
  constructor(n){ this.n=n; this.a=new Array(n); this.i=0; this.sum=0; this.count=0; }
  push(x){ if (this.count < this.n) { this.a[this.i] = x; this.sum += x; this.count++; } else { this.sum -= this.a[this.i]; this.a[this.i] = x; this.sum += x; } this.i = (this.i+1)%this.n; return this.sum / this.count; }
}

/* =========================
   Globals
   ========================= */
let video = document.getElementById('video');
let canvas = document.getElementById('canvas');
let ctx = canvas.getContext('2d');
let statusEl = document.getElementById('status');
let statsEl = document.getElementById('stats');
let cmdEl = document.getElementById('cmd');

let detector = null;
let lastTime = 0;
let lastProcessTime = 0;
let emaX = new EMA(CONFIG.EMA_ALPHA_X);
let emaShoulder = new EMA(CONFIG.EMA_ALPHA_SHOULDER);
let kalmanX = new Kalman(CONFIG.KALMAN_Q, CONFIG.KALMAN_R);
let pid = new PID(CONFIG.PID.kP, CONFIG.PID.kI, CONFIG.PID.kD);
let shoulderMA = new MovingAvg(30);

let ws = null;
let lastSentTime = 0;
let lastCommand = null;

/* =========================
   Networking (optional)
   ========================= */
function sendCommand(command){
  if (!command) return;
  // throttle identical commands to avoid network flood
  const now = Date.now();
  if (command === lastCommand && now - lastSentTime < 120) return;
  lastCommand = command; lastSentTime = now;

  if (CONFIG.sendMode === 'websocket'){
    if (!ws || ws.readyState !== WebSocket.OPEN){
      try {
        ws = new WebSocket(CONFIG.websocketUrl);
        ws.onopen = ()=> { ws.send(command); };
        ws.onclose = ()=> { console.warn('ws closed'); };
        ws.onerror = (e)=> { console.warn('ws error', e); };
      } catch (e) { console.warn('ws connect fail', e); }
    } else {
      ws.send(command);
    }
  } else if (CONFIG.sendMode === 'http'){
    fetch(`${CONFIG.httpUrl}?cmd=${encodeURIComponent(command)}`).catch(e => console.warn('http send fail', e));
  } else {
    // none — for testing
    // console.log('Command would be sent:', command);
  }
}

/* =========================
   Draw helpers (minimal)
   ========================= */
function clearCanvas(){ ctx.clearRect(0,0,canvas.width,canvas.height); }
function drawRect(x,y,w,h,color='rgba(0,255,0,0.3)'){ ctx.strokeStyle=color; ctx.lineWidth=2; ctx.strokeRect(x,y,w,h); }
function drawCircle(x,y,r,color='rgba(255,200,0,0.9)'){ ctx.fillStyle=color; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }

/* =========================
   Core compute and control
   ========================= */
function computeAndCommand(L, R, dt){
  // L and R are keypoint objects with x,y,score
  // 1) raw center, shoulder dist
  const rawCenterX = (L.x + R.x) * 0.5;
  const shoulderRaw = Math.abs(L.x - R.x);

  // 2) smoothing (EMA -> Kalman)
  const xEma = emaX.update(rawCenterX);
  const xKal = kalmanX.update(xEma);

  const shEma = emaShoulder.update(shoulderRaw);
  const shAvg = shoulderMA.push(shEma);

  // 3) compute errors
  const screenCenter = canvas.width * 0.5;
  const errX = xKal - screenCenter;
  const pidAdj = pid.update(errX, dt);

  // 4) adaptive deadzone
  const adaptiveDead = CONFIG.HORIZ_BASE_DEADZONE + Math.abs(pidAdj) * 8;

  // 5) distance thresholds
  const forwardThresh = shAvg * 0.75;
  const backwardThresh = shAvg * 1.35;

  // 6) decide
  let horiz = 'CENTER';
  if (errX < -adaptiveDead) horiz = 'LEFT';
  else if (errX > adaptiveDead) horiz = 'RIGHT';

  let distance = '';
  if (shEma < forwardThresh) distance = 'FORWARD';
  else if (shEma > backwardThresh) distance = 'BACKWARD';

  const command = distance ? `${distance}_${horiz}` : horiz;
  return {command, debug:{errX:Math.round(errX), pidAdj:pidAdj.toFixed(2), adaptiveDead:Math.round(adaptiveDead), shEma:Math.round(shEma), shAvg:Math.round(shAvg)}};
}

/* =========================
   Throttled, adaptive detection loop
   ========================= */
async function detectLoop(now){
  if (!detector) return;
  // adaptive throttle: if processing took too long, reduce effective fps by skipping frames
  const targetInterval = 1000 / CONFIG.TARGET_FPS;
  if (now - lastTime < targetInterval) { requestAnimationFrame(detectLoop); return; }
  lastTime = now;

  const t0 = performance.now();

  clearCanvas();
  // draw scaled video into canvas quickly (not strictly needed, but gives preview)
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  try {
    // estimate poses
    const poses = await detector.estimatePoses(video, { maxPoses: 1, flipHorizontal: false });
    const t1 = performance.now();

    let commandText = '--';
    if (poses && poses.length) {
      const p = poses[0];
      // MoveNet COCO format: left shoulder index 5, right shoulder index 6
      const L = p.keypoints[5], R = p.keypoints[6];
      if (L.score >= CONFIG.MIN_KEYPOINT_SCORE && R.score >= CONFIG.MIN_KEYPOINT_SCORE) {
        if (CONFIG.debugDraw) {
          drawCircle(L.x, L.y, 6, 'rgba(255,0,0,0.9)');
          drawCircle(R.x, R.y, 6, 'rgba(255,0,0,0.9)');
        }

        const dt = Math.max(0.001, (t1 - lastProcessTime) / 1000);
        const {command, debug} = computeAndCommand(L, R, dt);

        // debug display
        statusEl.innerText = `Status: running | PID:${debug.pidAdj} errX:${debug.errX}`;
        statsEl.innerHTML = `<small>fps:${(1000/(t1 - t0)).toFixed(1)} latency:${Math.round(t1 - t0)}ms</small>`;

        commandText = command;
        cmdEl.innerText = `Command: ${command}`;

        // draw alignment guide
        if (CONFIG.debugDraw) {
          const centerX = (L.x + R.x) * 0.5;
          drawCircle(centerX, 40, 6, 'rgba(255,200,0,0.95)');
          const band = CONFIG.HORIZ_BASE_DEADZONE + Math.abs(debug.pidAdj) * 8;
          ctx.strokeStyle = 'rgba(0,255,0,0.3)';
          ctx.lineWidth = 2;
          ctx.strokeRect(canvas.width/2 - band, 20, band*2, 48);
        }

        // send
        sendCommand(command);
      } else {
        // low confidence - don't change command; optionally send STOP
        statusEl.innerText = 'Status: low confidence - holding';
      }
    } else {
      statusEl.innerText = 'Status: person not found';
    }

    lastProcessTime = t1;
  } catch (err) {
    console.error('detection error', err);
    statusEl.innerText = 'Status: detection error - recovering';
    // small backoff on error
    await new Promise(r => setTimeout(r, 200));
  }

  requestAnimationFrame(detectLoop);
}

/* =========================
   Initialization
   ========================= */
async function init(){
  statusEl.innerText = 'Status: initializing TF backend';
  try {
    await tf.setBackend('webgl');
    await tf.ready();
  } catch (e) {
    console.warn('webgl backend failed, falling back to cpu', e);
    try { await tf.setBackend('cpu'); await tf.ready(); } catch (ee) { throw ee; }
  }

  // request camera with reduced resolution for speed
  statusEl.innerText = `Status: requesting camera ${CONFIG.REQUESTED_WIDTH}x${CONFIG.REQUESTED_HEIGHT}`;
  try {
    const constraints = {
      video: {
        width: { ideal: CONFIG.REQUESTED_WIDTH },
        height: { ideal: CONFIG.REQUESTED_HEIGHT },
        facingMode: 'environment'
      },
      audio: false
    };
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    await new Promise(r => video.onloadeddata = r);
    video.play();
    // set canvas size to match actual video resolution for best coordinate mapping
    canvas.width = video.videoWidth || CONFIG.REQUESTED_WIDTH;
    canvas.height = video.videoHeight || CONFIG.REQUESTED_HEIGHT;
  } catch (err) {
    alert('Camera error: ' + err.message);
    throw err;
  }

  statusEl.innerText = 'Status: loading MoveNet';
  detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, { modelType: CONFIG.MOVE_NET_MODEL });

  statusEl.innerText = 'Status: ready';
  lastTime = performance.now();
  lastProcessTime = performance.now();
  requestAnimationFrame(detectLoop);
}

/* =========================
   Start
   ========================= */
window.addEventListener('load', () => {
  statusEl = document.getElementById('status');
  statsEl = document.getElementById('stats');
  cmdEl = document.getElementById('cmd');
  init().catch(e => { statusEl.innerText = 'Init failed: ' + e; console.error(e); });
});

</script>
</body>
</html>
